#!/usr/bin/env ruby

require 'find'
require 'tempfile'
require 'set'

require_relative 'lib/errors'
require_relative 'lib/fileutilities'
require_relative 'lib/help'
require_relative 'lib/git'

CONFIG_FILE_EXTENSION = ".git-god"
TEMP_CONFIG = "temp.git-god"
LOGGED = "logged"
DEFAULT_START_LOG = "["
DEFAULT_END_LOG = "]"
ADD = "add"
ALL = "all"
PUSH_ORIGIN = "push_origin"
ISSUE = "issue"
CURRENT_ISSUE = "current_issue"
ISSUE_DELIMITER = "#"
CLOSES = "Closes"
CONTRIBUTORS = "Contributors:"
MENTION = "@"
ISSUE_MENTION = "#"
PULL_ORIGIN = "pull_origin"
RUN_SCRIPT = "run_script"
MASTER = "master"
COMMA = ", "
EXIT_SUCCESS = 0

LOG_PRIORITY = 0
ADD_PRIORITY = 1
PUSH_ORIGIN_PRIORITY = 2
PULL_ORIGIN_PRIORITY = 3
CURRENT_PRIORITY = 4

def check_params_del(arg_spl, args)
  if args.length == 2
    Errors.show_no_log_included_error
  end

  if arg_spl.length == 1
    Errors.show_delimiter_empty_error
  end
end

def handle_log(args, index)
  start_del = DEFAULT_START_LOG
  end_del = DEFAULT_END_LOG

  if args.length == 1
    Errors.show_no_log_included_error
  end

  args.each_with_index do |arg, i|
    arg_spl = arg.split("=")
    case arg_spl[0]
      when "-del"

      check_params_del(arg_spl, args)

      # only one character provided, use for both
      if arg_spl[1].length == 1
        log(args, i, arg_spl[1][0], arg_spl[1][0])
        return
      elsif arg_spl[1].length == 2 then
        log(args, i, arg_spl[1][0], arg_spl[1][1])
        return
      else
        Errors.show_invalid_delimiter_error
      end
    end
  end

  log(args, index, start_del, end_del)
end


def log(args, index, start_del, end_del)
  # find the previous logged info
  log_users = ""
  file = open_config_file

  args[index + 1..-1].each do |arg|
    puts "Logged: #{arg}"
    log_users += start_del + arg + end_del
  end

  FileUtilities.write_to_file_or_overwrite(LOGGED, "#{LOGGED}=#{log_users}")
  file.close
end

def remove_config(args, index)
  config_file = open_config_file
  should_delete_current_issue = false
  if args.length == 1
    # flag is only -r, delete whole configuration
  if File.exist?(CONFIG_FILE) then File.delete(CONFIG_FILE) end
  else
    # delete specific attributes
    args[index + 1..-1].each do |flag|
      key = get_key_from_flag(flag)
      # would delete all issues in case key is issue
      if key == ISSUE then should_delete_current_issue = true end
      file = FileUtilities.delete_line_with_key(key)
      config_file = file
    end
  end

  # if all issues are deleted then also delete the current issue symbol
  if should_delete_current_issue then FileUtilities.delete_line_with_key(CURRENT_ISSUE) end
  config_file.close
end

def show_status
  info = Hash.new
  issues = Set.new
  scripts = Array.new
  config_file = open_config_file
  config_file.each_line do |line|
    line_array = line.split("=")
    value = line_array[1..-1]
    case line_array[0]
      when LOGGED
        info[LOG_PRIORITY] = value
      when ADD
        info[ADD_PRIORITY] = value
      when PUSH_ORIGIN
        info[PUSH_ORIGIN_PRIORITY] = value
      when PULL_ORIGIN
        info[PULL_ORIGIN_PRIORITY] = value
      when ISSUE
        issues << value
      when CURRENT_ISSUE
        info[CURRENT_PRIORITY] = value
      when RUN_SCRIPT
        scripts << value
    end
  end

  config_file.close

  # shows single line configurable attributes, overridable
  info = Hash[info.sort]
  info.each do |k, v|
    case k
    when LOG_PRIORITY
      puts "logged: #{v[0]}"
    when ADD_PRIORITY
      if v[0].length != 0 then puts "add: " + ALL end
    when PUSH_ORIGIN_PRIORITY
      puts "pushing to: #{v[0]}"
    when PULL_ORIGIN_PRIORITY
      puts "pulling from: #{v[0]}"
    when CURRENT_PRIORITY
      puts "current issue: #{v[0]}"
    end
  end

  # if there is no current issue because it has been restored or never assigned
  if info[CURRENT_PRIORITY] == nil then puts "no current issues" end

  # shows the issues
  issues.each do |issue_line|
    if issue_line.length == 1
      puts "issue: #{issue_line[0]}"
    else
      puts "issue: #{issue_line[0]}, alias: #{issue_line[1]}"
    end
  end

  # shows the scripts to be run before pushing anything
  scripts.each do |script_line|
    puts "script: #{script_line[0]}"
  end

end

def get_values
  info = Hash.new
  issues = Set.new
  scripts = Array.new
  config_file = open_config_file
  config_file.each_line do |line|
    line_array = line.strip.split("=")
    case line_array[0]
      when ISSUE
        # case when it is an issue, need to track name and alias
        alias_for_name = ""
        if line_array[2] != nil then alias_for_name = line_array[2] end
        issues << line_array[1] + "=" + alias_for_name
      when RUN_SCRIPT
        scripts << line_array[1]
      else
        info[line_array[0]] = line_array[1]
    end
  end
  [info, issues, scripts]
end

def open_config_file
  File.open(CONFIG_FILE, "r+")
end

def commit(args, flag, should_commit)
  values, _, _ = get_values

  message = generate_msg_for_commit(values, args, flag, should_commit)
  # if the flag is set, commit, otherwise just print the commit
  if should_commit
    add_and_commit(values, message)
  else
    puts message
  end
end

def generate_msg_for_commit(values, args, flag, should_commit)

  if should_commit and args.length < 2 then Errors.show_invalid_size_commit(flag) end

  # if there are enough arguments, check that the first one to the commit flag
  # is not a flag
  if args.length > 1 and flag?(args[1])
    Errors.show_flag_expect_message_error(flag, args[1])
  end

  log_users = values[LOGGED]
  issue = values[CURRENT_ISSUE]

  message = ""

  if defined_val?(issue)
    message += "(" + ISSUE_DELIMITER + issue.strip + ") "
  end


  if defined_val?(log_users)
    message += log_users
  end

  message += " " + args[1].to_s

  if args.length > 2
    # commit message might have additional flags
    # starting from third argument
    message = additional_flags_to_commit(args, message, 2, flag)
  end
  message
end

def add_and_commit(values, message)
  add_atts = values[ADD]
  if defined_val?(add_atts)
    puts "adding all"
    Git.add_all
  end
  puts "commiting..."
  puts "\"#{message}\""
  Git.commit message
end

def additional_flags_to_commit(args, message, index, flag)
  # starting from the third argument
  case args[index]
  when "-cl"
    closes(args, message, index, flag)
  when "-ct"
    contributes(args, message, index, flag)
  end
end

def closes(args, message, index_on_entry, flag)
  # if the arguments are less than the given index plus one argument, throw an error
  add_appending_flag(args, message, index_on_entry, flag, CLOSES, ISSUE_MENTION, COMMA)
end


def contributes(args, message, index_on_entry, flag)
  add_appending_flag(args, message, index_on_entry, flag, CONTRIBUTORS, MENTION, COMMA)
end

def add_appending_flag(args, message, index_on_entry, flag, preceding, before_ref, join)
  if args.length <= index_on_entry + 1 then Errors.show_invalid_size_commit(flag) end
  refs = Array.new
  # start at argument
  index = index_on_entry + 1
  while index < args.length and not flag?(args[index]) do
    refs << args[index]
    index += 1
  end
  refs = add_to_start(refs, before_ref)
  refs = refs.join(join)
  stripped_msg = args[1].strip
  # if the last character is a full stop or the message is empty then dont add
  # another full stop

  total_msg_strip = message.strip
  if total_msg_strip[total_msg_strip.length - 1] == '.' or stripped_msg.length == 0
    message = message + " #{preceding} #{refs}."
  else
    message = message + ". #{preceding} #{refs}."
  end
  if index < args.length
    message = additional_flags_to_commit(args, message, index, flag)
  end
  message
end

def add_to_start(refs, before_ref)
  result = Array.new
  refs.each do |ref|
    result << before_ref + ref
  end
  result
end

def flag?(str)
  str[0] == '-'
end


def push(args, flag, load_configuration, less_than_two_args)

  if less_than_two_args and args.length > 2
    Errors.show_too_many_args_error(flag, 1, args.length - 1)
  end

  values, _, scripts = get_values
  # if always load from configuration then it is a -p from -cp
  if load_configuration
    push_attributes = values[PUSH_ORIGIN]
  else
  # if we do not need to load from configuration, and there is a branch push to
  # that branch. If there is not a branch, then it will be nil, and will default
  # to master
    if args.length == 2
      push_attributes = args[1]
    else
      # there is only one argument, get from configuration
      # if configuration is nil then will default to master below
      push_attributes = values[PUSH_ORIGIN]
    end
  end

  exit_statuses = Array.new
  # execute every script
  scripts.each do |script|
    puts "Script: #{script}"

    execute_script script

    unless $?.exitstatus == EXIT_SUCCESS
      puts "Script: #{script} failed with exit code #{$?.exitstatus}"
      # only add the exit status to the array if it was non zero
      exit_statuses << $?.exitstatus
    end
    puts ""
  end

  # if it is not empty, then some script returned a non zero exit code, so do not push
  unless exit_statuses.empty?
    Errors.show_push_aborted
  end

  # push after all scripts have run and exit code was success
  if not defined_val?(push_attributes)
    puts "pushing to master"
    Git.push_origin MASTER
  else
    puts "pushing to #{push_attributes}"
    Git.push_origin push_attributes
  end
end

def script(args, flag)

  if args.length == 1
    Errors.show_at_least_args_error(flag, 1, 0)
  end

  # write the runnable script with the arguments directly to file
  FileUtilities.write_to_file(CONFIG_FILE, "#{RUN_SCRIPT}=#{args[1..-1].join(" ")}")
end

def execute_script(script)
  if executable_script? script
    # then we cd into the root git directory and run it from there
    Dir.chdir(Git.get_top_level.strip) do
      # if root contains script execute
      return unless directory_contains? script
      system script
    end
  else
    # it is a normal command, execute normally
    # prevent errors from ruby when command is malformed
    system script
  end

end

def directory_contains?(script)
  Find.find(Dir.pwd) do |entry|
    # it is an executable script
    return true if entry == File.absolute_path(script[2..-1])
  end
  Errors.show_script_not_in_root_error script, false
  false
end

def executable_script?(script)
  script[0..1] == "./"
end

def push_atts(args)
  if args.length == 1
    Errors.show_push_atts_no_atts_error
  end

  args[1..-1].each do |value|
    value_spl = value.split("=")
    if value_spl.length == 1 then Errors.show_push_atts_no_atts_error end
    case value_spl[0]
    when "-o"
      FileUtilities.write_to_file_or_overwrite(PUSH_ORIGIN, "#{PUSH_ORIGIN}=#{value_spl[1]}")
    else
      Errors.show_unsupported_command(value_spl[0])
    end
  end
end

def pull(args, flag)
  if args.length > 2 then Errors.show_too_many_args_error(flag, 1, args.length - 1) end

  values, _, _ = get_values

  if args.length == 1
    # grab pull origin from configuration
    pull_origin = values[PULL_ORIGIN]
  else
    # length must be two, therefore use the argument given as origin
    pull_origin = args[1]
  end

  unless defined_val?(pull_origin)
    # if not defined in configuration file and not given in argument to flag
    # then choose master by default
    pull_origin = MASTER
  end

  puts "pulling from #{pull_origin}"
  Git.pull_origin pull_origin
end

def pull_atts(args)
  if args.length == 1
    Errors.show_pull_atts_no_atts_error
  end

  args[1..-1].each do |value|
    value_spl = value.split("=")
    if value_spl.length == 1 then Errors.show_pull_atts_no_atts_error end
    case value_spl[0]
    when "-o"
      FileUtilities.write_to_file_or_overwrite(PULL_ORIGIN, "#{PULL_ORIGIN}=#{value_spl[1]}")
    else
      Errors.show_unsupported_command(value_spl[0])
    end
  end
end



def defined_val?(val)
  val != nil
end

def always_add_all
  FileUtilities.write_to_file_or_overwrite(ADD, "#{ADD}=#{ALL}")
end

def get_key_from_flag(flag)
  unless configurable?(flag)
    Errors.show_non_removable_config flag
  end
  case flag
    when "l"
      LOGGED
    when "pc"
      PUSH_ORIGIN
    when "plc"
      PULL_ORIGIN
    when "a"
      ADD
    when "i"
      ISSUE
    when "scr", "script"
      RUN_SCRIPT
  end
end

def configurable?(flag)
  flag == "l" or flag == "pc" or flag == "a" or flag == "i" or
      flag == "plc" or flag == "scr" or flag == "script"
end

def issue(args, index)
  unless correct_issue_arg_length(args)
    Errors.show_no_name_or_alias_error
  end
  # if length is one, then we want to commit without issue
  if args.length == 1
    FileUtilities.delete_line_with_key(CURRENT_ISSUE)
    exit(0)
  end
  name = ""
  alias_for_name = nil

  args[index + 1..-1].each do |arg|
    arg_spl = arg.split("=")
    case arg_spl[0]
    when "-name", "-n"
      name = arg_spl[1]
    when "-alias", "-a"
      alias_for_name = arg_spl[1]
    else
      values, _, _ = get_values
      if arg_spl[0][1..-1] == values[CURRENT_ISSUE]
        exit(0)
      end
      # it must be an alias or name
      name = get_name_from_alias(arg_spl[0][1..-1].strip)
      if name == nil then Errors.show_error_issue_not_exist(arg_spl[0][1..-1]) end
      FileUtilities.write_to_file_or_overwrite(CURRENT_ISSUE, "#{CURRENT_ISSUE}=#{name}")
      puts "Current issue: #{name}"
      exit(0) # job is done, no need to add any issues
    end
  end

  if name == nil then Errors.show_no_name_for_issue_error end

  # writeToFile leaves config_file closed
  if alias_for_name == nil
    FileUtilities.write_to_file_or_overwrite(CURRENT_ISSUE, "#{CURRENT_ISSUE}=#{name}")
    FileUtilities.write_to_file(CONFIG_FILE, "#{ISSUE}=#{name}")
  else
    FileUtilities.write_to_file_or_overwrite(CURRENT_ISSUE, "#{CURRENT_ISSUE}=#{name}=#{alias_for_name}")
    FileUtilities.write_to_file(CONFIG_FILE, "#{ISSUE}=#{name}=#{alias_for_name}")
  end

end

def get_name_from_alias(alias_or_name)
  config_file = open_config_file
  begin
    config_file.each_line do |line|
      line_spl = line.strip.split("=")
      next if line_spl[0] != ISSUE
      # line is an issue
      if alias_or_name == line_spl[1] or alias_or_name == line_spl[2]
        return line_spl[1]
      end
    end
    # if not found return nil
    nil
  ensure
    config_file.close
  end
end

def correct_issue_arg_length(args)
  args.length >= 1 and args.length <= 3
end

def check_if_git_repo
  # suppressing the output of git status
  system "git", "status", :out => File::NULL, :err => File::NULL
  if $?.exitstatus != EXIT_SUCCESS
    Errors.show_not_git_repo_error
  end
end

def new_branch(args, flag)
  only_allow_one_arg args, flag
  branch_name = args[1]
  puts "creating new branch: #{branch_name}"
  Git.checkout branch_name
end

def checkout_branch(args, flag)
  only_allow_one_arg args, flag
  branch_name = args[1]
  puts "checkout to branch #{branch_name}"
  Git.checkout branch_name
end

def clone(args, flag)
  only_allow_one_arg args, flag
  repo = args[1]
  puts "cloning #{repo}"
  Git.clone repo
end

def delete_branch(args, flag)
  only_allow_one_arg args, flag
  branch = args[1]
  puts "deleting #{branch}"
  Git.delete_branch branch
end

def merge(args, flag)
  only_allow_one_arg args, flag
  branch = args[1]
  current_branch = Git.get_current_branch
  puts "merging #{branch} to #{current_branch}"
  Git.merge branch
end

def only_allow_one_arg(args, flag)
  if args.length > 2 then Errors.show_too_many_args_error(flag, 1, args.length - 1) end
  if args.length == 1 then Errors.show_not_enough_args_error(flag, 1, 0) end
end

def protected_commit_push(args, flag)
  unless args.length >= 2
    Errors.show_at_least_args_error(flag, 2, args.length)
  end
  current_branch = Git.get_current_branch.strip
  target_branch = args[1]
  puts "updating current branch: #{current_branch}, pulling from #{target_branch}"
  Git.pull_origin target_branch
  should_commit = true
  commit(args[2..-1], flag, should_commit)
  args_for_push = [flag, current_branch]
  push(args_for_push, flag, false, true)
end

# after cloning we do not want to do anything else as we would not be yet inside the git repository
def exec_if_clone_command_and_exit(args, clone_flag)
  if args[0] == clone_flag
    clone(args, clone_flag)
    exit EXIT_SUCCESS
  end
end

# cloning is the only operation currently supported that is executed externally, out of a git repository
exec_if_clone_command_and_exit ARGV, "cn"
# check if it is a git repository
check_if_git_repo

top_level = Git.get_top_level
CONFIG_FILE = File.join(top_level.strip, CONFIG_FILE_EXTENSION)

# create configuration file if it does not exist
unless File.exist?(CONFIG_FILE)
  config_file = File.open(CONFIG_FILE, "w+")
  config_file.close
end

arg = ARGV[0]
index = 0
case arg
  when "a"
    always_add_all
  when "b"
    Git.get_local_branches
  when "ba"
    Git.get_all_branches
  when "c"
    commit(ARGV, "c", true)
  when "cb"
    # show current branch
    puts Git.get_current_branch
  when "ch"
    checkout_branch(ARGV, "ch")
  when "-commands"
    Help.print_commands
  when "cp"
    commit(ARGV, "cp", true)
    # do not expect more arguments
    push(ARGV, "cp", true, false)
  when "d"
    delete_branch(ARGV, "d")
  when "di"
    Git.get_diff
  when "fa"
    Git.fetch_all
  when "gs"
    Git.get_status
  when "i"
    issue(ARGV, index)
  when "l"
    handle_log(ARGV, index)
  when "m"
    merge(ARGV, "m")
  when "nb"
    new_branch(ARGV, "nb")
  when "op"
    system "vim #{CONFIG_FILE}"
  when "p"
    # load from configuration unless it is specified
    push(ARGV, "p", false, true)
  when "pc"
    push_atts(ARGV)
  when "pl"
    pull(ARGV, "pl")
  when "plc"
    pull_atts(ARGV)
  when "prcp"
    protected_commit_push(ARGV, "prcp")
  when "r"
    remove_config(ARGV, index)
  when "ro"
    puts Git.get_top_level
  when "status", "s"
    show_status
  when "sc"
    # do not commit, only show message
    commit(ARGV, "c", false)
  when "script", "scr"
    script(ARGV, "script/scr")
  when "u"
    Git.get_url
  else
    Errors.show_unsupported_command(arg)
end
